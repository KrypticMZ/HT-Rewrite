package me.htrewrite.client.module.modules.exploit;

import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
import me.htrewrite.client.command.commands.CoordExploitCommand;
import me.htrewrite.client.event.custom.CustomEvent;
import me.htrewrite.client.event.custom.client.ClientSettingChangeEvent;
import me.htrewrite.client.event.custom.networkmanager.NetworkPacketEvent;
import me.htrewrite.client.event.custom.player.PlayerUpdateEvent;
import me.htrewrite.client.module.Module;
import me.htrewrite.client.module.ModuleType;
import me.htrewrite.client.util.Timer;
import me.htrewrite.exeterimports.mcapi.settings.ValueSetting;
import me.zero.alpine.fork.listener.EventHandler;
import me.zero.alpine.fork.listener.Listener;
import net.minecraft.client.multiplayer.ChunkProviderClient;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.network.play.server.SPacketBlockChange;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.chunk.Chunk;

import java.lang.reflect.Field;

public class CoordExploit3Module extends Module {
    public static final ValueSetting<Double> delay = new ValueSetting<>("Delay", .2d, .01d, 1d);

    private Timer timer;

    private Field loadedChunksField = null;
    private Long2ObjectMap<Chunk> getLoadedChunks() {
        if(loadedChunksField == null)
            return null;

        try {
            return (Long2ObjectMap<Chunk>)loadedChunksField.get((ChunkProviderClient)mc.world.getChunkProvider());
        } catch (IllegalAccessException exception) {}
        return null;
    }

    private BlockPos playerPos;
    private int renderDistanceDiameter, count;
    private int delayMs;
    public CoordExploit3Module() {
        super("CoordExploit3", "Coordinates exploit.", ModuleType.Exploits, 0);
        addOption(delay);
        endOption();

        timer = new Timer();
        playerPos = null;
        renderDistanceDiameter = count = 0;

        try {
            for(Field field : ChunkProviderClient.class.getFields())
                if((field.getName().contains("loadedChunks") || field.getName().contains("field_73236_b")) && loadedChunksField == null)
                    loadedChunksField = field;
            if(loadedChunksField == null)
                for(Field field : ChunkProviderClient.class.getDeclaredFields())
                    if((field.getName().contains("loadedChunks") || field.getName().contains("field_73236_b")) && loadedChunksField == null)
                        loadedChunksField = field;
            if(loadedChunksField != null) {
                loadedChunksField.setAccessible(true);
                System.out.println("Found CoordExploit3 field! " + loadedChunksField.getName());
            }
        } catch (Exception exception) { exception.printStackTrace(); }
    }

    private int[] getSpiralCoords(int n) {
        int x, z = x = 0, d, lineNumber = d = 1;
        int[] coords = {0, 0};
        for(int i = 0; i < n; i++) {
            if(2 * x * d < lineNumber) {
                x+=d;
                coords = new int[]{x, z};
            } else if(2 * z * d < lineNumber) {
                z += d;
                coords = new int[]{x, z};
            } else {
                d *= -1;
                lineNumber++;
                n++;
            }
        }
        return coords;
    }

    @Override
    public void onEnable() {
        super.onEnable();

        delayMs = (int)(delay.getValue()*1000);
        playerPos = null;
        count = 0;
    }

    @Override
    public void onDisable() {
        super.onDisable();

        playerPos = null;
        count = 0;
    }

    @EventHandler
    private Listener<ClientSettingChangeEvent> settingChangeEventListener = new Listener<>(event -> {
        if(event.setting == delay)
            delayMs = (int)(delay.getValue()*1000);
    });

    @EventHandler
    private Listener<PlayerUpdateEvent> updateEventListener = new Listener<>(event -> {
        Long2ObjectMap<Chunk> loadedChunks = getLoadedChunks();
        if(loadedChunks == null)
            return;

        playerPos = new BlockPos(mc.player.posX, mc.player.posY - 1, mc.player.posZ);
        if(renderDistanceDiameter == 0)
            renderDistanceDiameter = (int)Math.sqrt(loadedChunks.size());
        if(timer.passed(delayMs)) {
            final int x = getSpiralCoords(CoordExploitCommand.x)[0] * renderDistanceDiameter * 16;
            final int z = getSpiralCoords(CoordExploitCommand.z)[1] * renderDistanceDiameter * 16;
            final BlockPos blockPos = new BlockPos(x, 0, z);
            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.ABORT_DESTROY_BLOCK, playerPos, EnumFacing.EAST));
            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.ABORT_DESTROY_BLOCK, blockPos, EnumFacing.EAST));
            timer.reset();
            CoordExploitCommand.x = ++CoordExploitCommand.z;
        }
    });

    @EventHandler
    private Listener<NetworkPacketEvent> packetEventListener = new Listener<>(event -> {
        if(!(event.reading && event.getEra() == CustomEvent.Era.PRE && event.getPacket() instanceof SPacketBlockChange && getLoadedChunks() == null))
            return;

        final int x = ((SPacketBlockChange) event.getPacket()).getBlockPosition().getX();
        final int z = ((SPacketBlockChange) event.getPacket()).getBlockPosition().getZ();
        for(Chunk chunk : getLoadedChunks().values())
            if(chunk.x == x / 16 || chunk.z == z / 16)
                return;
        sendMessage("&aFound player! [" + x + ", " + z + "]");
    });
}